<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>What I Wish I Knew When Learning HoTT 0.1 ( Auke Booij )</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
        
    <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,700|Source+Code+Pro" rel="stylesheet">
    <style type="text/css">
      
    </style>

    
        <link rel="stylesheet" href="css/style.css" type="text/css" />
        <link rel="stylesheet" href="css/layout.css" type="text/css" />
    
          </head>

  <body itemscope itemtype="http://schema.org/TechArticle">
    <div id="sidebar-wrapper">
      <a href="https://abooij.github.io/wiwikwlhott/" class="logo">
        <img src="logo.svg" alt="Logo">
      </a>
      <button id="toggle-sidebar">
        Menu
      </button>
      <ul class="sidebar-nav">
<ul>
<li><a href="#changelog">Changelog</a></li>
<li><a href="#variants-of-hott">Variants of HoTT</a><ul>
<li><a href="#book-hott">Book HoTT</a></li>
<li><a href="#cubical-type-theory">Cubical type theory</a></li>
<li><a href="#hott-as-an-dsl">HoTT as an DSL</a></li>
<li><a href="#impredicative-prop-propositional-resizing">Impredicative prop / propositional resizing</a></li>
<li><a href="#hott-as-an-approach-to-mltt">HoTT as an approach to MLTT</a></li>
</ul></li>
<li><a href="#proof-assistants">Proof assistants</a><ul>
<li><a href="#coq">Coq</a></li>
<li><a href="#agda">Agda</a></li>
<li><a href="#cubicaltt">cubicaltt</a></li>
<li><a href="#normalization">Normalization</a></li>
<li><a href="#libraries">Libraries</a></li>
</ul></li>
<li><a href="#meta-theory">Meta-theory</a><ul>
<li><a href="#topology">Topology</a></li>
<li><a href="#homotopy">Homotopy</a></li>
<li><a href="#paths-and-continuity">Paths and continuity</a></li>
</ul></li>
<li><a href="#general-confusion-arising-from-names-of-definitions">General confusion arising from names of definitions</a><ul>
<li><a href="#constructors-versus-elements-versus-terms">Constructors versus elements versus terms</a></li>
<li><a href="#translating-claims-in-natural-language-to-type-theory">Translating claims in natural language to type theory</a></li>
<li><a href="#types-as-spaces">Types as spaces</a></li>
<li><a href="#sets">Sets</a></li>
</ul></li>
<li><a href="#type-theoretical-features">Type-theoretical features</a><ul>
<li><a href="#inductionrecursion-inductionrecursion">{induction,recursion}-{induction,recursion}</a></li>
<li><a href="#initial-algebras">Initial algebras</a></li>
<li><a href="#coinduction">Coinduction</a></li>
</ul></li>
<li><a href="#category-theory">Category theory</a><ul>
<li><a href="#topos-logic-versus-hott">Topos logic versus HoTT</a></li>
</ul></li>
<li><a href="#semantics">Semantics</a><ul>
<li><a href="#categories-with-families">Categories with families</a></li>
<li><a href="#fibrations">Fibrations</a></li>
<li><a href="#simplicial-sets">Simplicial sets</a></li>
<li><a href="#cubical-sets">Cubical sets</a></li>
</ul></li>
</ul>
      </ul>
    </div>

    <div id="main-wrapper">
      <div id="main">
        <h1 class="document-title" itemprop="name">
          What I Wish I Knew When Learning HoTT
        </h1>
        <p itemprop="version" class="document-version">
        Version
        <span class="version">0.1</span>
        </p>
<p>Auke Booij</p>
<p>This document is intended to refer to concepts one may not be aware of on a first reading of the HoTT book, and give a crude, possible unhelpful intuition for them.</p>
<p><strong>Warning</strong>: I did not check for correctness. This document may be counterproductive. You didn't get these things from me.</p>
<h2 id="changelog">Changelog</h2>
<p><strong>0.1</strong></p>
<p>First sections:</p>
<ul>
<li>???</li>
</ul>
<hr/>
<h1 id="variants-of-hott">Variants of HoTT</h1>
<h2 id="book-hott">Book HoTT</h2>
<p>Book HoTT is the type theory described in the HoTT book. It is intensional MLTT with a hierarchy of universes indexed by positive numerals, and additionally:</p>
<ul>
<li>univalence as an axiom (and function extensionality as a theorem),</li>
<li><span class="math inline"><em>n</em></span>-truncation,</li>
<li>suspension types,</li>
<li>pushouts,</li>
<li>set quotients,</li>
<li>the free Cauchy completion of the rationals <span class="math inline"><strong>R</strong><sub><em>C</em></sub></span>,</li>
</ul>
<p>where the computation rules for HITs is given definitionally for points but propositionally for higher constructors.</p>
<h2 id="cubical-type-theory">Cubical type theory</h2>
<p>Cubical type theory is a type theory for which univalence is a theorem. It adds an interval <em>pretype</em> which is used to define identity types. This interval is necessarily not a type.</p>
<p>Cubical type theory was implemented in the <strong>cubicaltt</strong> proof assistant and the agda <strong>--cubical</strong> mode.</p>
<p>Although univalence is a theorem, the normal form is huge (megabytes), although it is argued that this is due to the proof rather than the design of cubical type theory.</p>
<h2 id="hott-as-an-dsl">HoTT as an DSL</h2>
<p>Dan Licata argues we should think of HoTT as a language to which we add features depending on how we plan to use it, in the same way that we write specialized programming languages for specific use-cases. For example, cubical type theory is a domain-specific language for programming with Kan cubical sets, and real-cohesive HoTT is a language for programming topological spaces. Schulman and Riehl have a language for programming <span class="math inline">(‚àû,1)</span>-categories.</p>
<h2 id="impredicative-prop-propositional-resizing">Impredicative prop / propositional resizing</h2>
<p>The principle that there is only one type <span class="math inline"><em>Œ©</em></span> of propositions, and it is a member of <span class="math inline">ùí∞<sub>0</sub></span>: so all types of propositions <span class="math inline">Prop<sub><em>i</em></sub></span> are equal, and it is a type in the lowest universe.</p>
<p>Assuming this principle, the set of types of any universe is a topos.</p>
<p>Assuming this principle, some HITs become definable by impredicative encoding: e.g. truncation as <span class="math inline">‚àè<sub><em>P</em>‚ÄÑ:‚ÄÑ<em>Œ©</em></sub>(<em>X</em>‚ÄÑ‚Üí‚ÄÑ<em>P</em>)‚Üí<em>P</em></span>.</p>
<p>UniMath uses propositional resizing in the foundational files <code>Foundations/PartA.v</code> and <code>Foundations/PartB.v</code> to avoid depending on univalence early.</p>
<h2 id="hott-as-an-approach-to-mltt">HoTT as an approach to MLTT</h2>
<p>Parts of HoTT can be developed in intensional MLTT, that is, without assuming univalence, function extensionality, propositional extensionality, or the existence of any HITs. For example:</p>
<ul>
<li>The fact that h-levels are cumulative (if <span class="math inline"><em>A</em></span> is an <span class="math inline"><em>n</em></span>-type then it is also an <span class="math inline"><em>n</em>‚ÄÖ+‚ÄÖ1</span>-type) does not require univalence.</li>
<li>The groupoid laws of identity types and iterated identity types can be proved by simple path inductions.</li>
<li>Some propositional truncations exist without assuming the existence of any HITs or propositional resizing, such as the type of fixed-points of any constant endomap <span class="math inline"><em>f</em></span> on <span class="math inline"><em>X</em></span>.</li>
</ul>
<h1 id="proof-assistants">Proof assistants</h1>
<h2 id="coq">Coq</h2>
<p>Coq consists of several layers of programming language. The most famous one is the tactic language that is used to prove theorems. But since theorems are interpreted by types, really tactics just construct terms. For example:</p>
<pre><code>Definition logeq_both_false {X Y : UU} : ¬¨X -&gt; ¬¨Y -&gt; (X &lt;-&gt; Y).
Proof.
  intros ? ? nx ny.
  split.
  - intros x. induction (nx x).
  - intros y. induction (ny y).
Defined.

Print logeq_both_false.</code></pre>
<p>prints:</p>
<pre><code>logeq_both_false =
Œª (X Y : UU) (nx : ¬¨ X) (ny : ¬¨ Y),
(Œª (x : X) (e:=nx x), empty_rect (Œª _ : ‚àÖ, Y) e),, (Œª (y : Y) (e:=ny y), empty_rect (Œª _ : ‚àÖ, X) e)
     : ‚àè X Y : UU, ¬¨ X ‚Üí ¬¨ Y ‚Üí X &lt;-&gt; Y</code></pre>
<p>(<code>empty_rect</code> is the induction principle for <span class="math inline"><strong>0</strong></span>.)</p>
<ul>
<li>tactic language is just a way to construct type-theoretical terms: can get term out of proof by tactics</li>
</ul>
<h2 id="agda">Agda</h2>
<h2 id="cubicaltt">cubicaltt</h2>
<ul>
<li>interval is abstract (as opposed to, say, an interval of reals): cubical set (though necessarily <em>not</em> Kan, see semantics section)</li>
<li>earlier iteration: cubical</li>
</ul>
<h2 id="normalization">Normalization</h2>
<ul>
<li>minor gotcha: even if your particular flavor of hott is strongly normalizing (so that all terms reduce to a unique normal form), there are still types without decidable equality, because there is no map inside type theory that computes normal forms of arbitrary terms. find a way to say this without hopping back and forth between meta-theoretical and internal statements.</li>
</ul>
<h2 id="libraries">Libraries</h2>
<ul>
<li>UniMath</li>
<li>HoTT/HoTT coq library</li>
<li>HoTT-Agda</li>
<li>cubical agda library</li>
<li>examples/ directory in cubicaltt repository</li>
<li>lean</li>
<li>various scientists' personal libraries</li>
<li></li>
</ul>
<h1 id="meta-theory">Meta-theory</h1>
<h2 id="topology">Topology</h2>
<p>HoTT is <em>not</em> a internal language for topology. TODO: say something about modalities that is correct.</p>
<h2 id="homotopy">Homotopy</h2>
<p>Within the HoTT community, &quot;homotopy theory&quot; refers to abstract homotopy theory in the sense of, for example, Quillen model categories, or more generally homotopy categories. The category of topological spaces and continuous maps is one such model category. However, it is not clear if HoTT is an internal language for <em>all</em> model categories. In particular, the &quot;homotopy&quot; of HoTT does not (necessarily) refer to the homotopies of point-set topology.</p>
<h2 id="paths-and-continuity">Paths and continuity</h2>
<ul>
<li>continuity of functions on the reals or other metric spaces</li>
</ul>
<h1 id="general-confusion-arising-from-names-of-definitions">General confusion arising from names of definitions</h1>
<h2 id="constructors-versus-elements-versus-terms">Constructors versus elements versus terms</h2>
<p>To say that something is a <em>constructor</em> of a type <span class="math inline"><em>A</em></span> means that the type <span class="math inline"><em>A</em></span> was defined inductively, and that you are picking one of the options specifying its datatype. For example, <span class="math inline"><strong>N</strong></span> has exactly <em>two</em> constructors: <span class="math inline">0</span> and <span class="math inline"><em>S</em></span>. But since, for example, <span class="math inline"><em>S</em></span> has type <span class="math inline"><strong>N</strong>‚ÄÑ‚Üí‚ÄÑ<strong>N</strong></span>, constructors of a type are not always elements of that type.</p>
<p>To say that something is an <em>element</em> of a type <span class="math inline"><em>A</em></span> means that it is a variable or expression whose type is <span class="math inline"><em>A</em></span>. But that means that, in some non-trivial context, you can have an element of type <span class="math inline"><strong>0</strong></span>: for example in the context <span class="math inline"><em>x</em>‚ÄÑ:‚ÄÑ<strong>0</strong></span>, we have the element <span class="math inline"><em>x</em></span> of type <span class="math inline"><strong>0</strong></span>.</p>
<p>Confusingly, even in the context <span class="math inline"><em>x</em>‚ÄÑ:‚ÄÑ<strong>0</strong></span>, where we have the element <span class="math inline"><em>x</em></span> of type <span class="math inline"><strong>0</strong></span>, we can show that <span class="math inline"><strong>0</strong></span> does not have any elements, because the claim &quot;<span class="math inline"><em>A</em></span> does not have any elements&quot; is formalised as <span class="math inline">¬¨<em>A</em></span>, that is, <span class="math inline"><em>A</em>‚ÄÑ‚Üí‚ÄÑ<strong>0</strong></span>, and <span class="math inline"><strong>0</strong>‚ÄÑ‚Üí‚ÄÑ<strong>0</strong></span> is indeed inhabited (by the identity function).</p>
<p><em>Point</em> is a synonym for <em>element</em>.</p>
<p>Finally, <em>term</em> is a strictly syntactic notion. As a first approximation, something is a term if it is a string of characters that, when inserted in a proof assistant, would parse, and have a certain type. There are no terms of type <span class="math inline"><strong>0</strong></span> (unless HoTT turns out to be inconsistent).</p>
<h2 id="translating-claims-in-natural-language-to-type-theory">Translating claims in natural language to type theory</h2>
<ul>
<li>there seems to be some miscommunication regarding which statements by HoTTist are internal and which ones are metatheoretical, but I can't find the right words to make this precise right now.</li>
</ul>
<h2 id="types-as-spaces">Types as spaces</h2>
<p>There are (at least) two different notion of &quot;space&quot; and (at least) two different &quot;circles&quot;.</p>
<p>First of all, every type is <em>thought of</em> as a space: and so the HIT <span class="math inline"><em>S</em><sup>1</sup></span> freely generated by a basepoint and a path on that basepoint is thought of as a homotopical circle. The space-like behavior is given by the type theory, and can be probed using identity types.</p>
<p>Secondly, there is a certain subset of the real plane <span class="math inline"><strong>R</strong><sup>2</sup></span> (taking <span class="math inline"><strong>R</strong></span> to be, for example, the dedekind reals) that represents a circle, namely the subtype of points with radius 1. The space-like behavior of such spaces <em>internal to the theory</em> is given by whatever notion of space we are interested in: for example, <span class="math inline"><strong>R</strong><sup>2</sup></span> is often studies as a metric space with a metric <span class="math inline"><em>d</em>‚ÄÑ:‚ÄÑ<strong>R</strong><sup>2</sup>‚ÄÖ√ó‚ÄÖ<strong>R</strong><sup>2</sup>‚ÄÑ‚Üí‚ÄÑ<strong>R</strong></span>.</p>
<p>These two circles are completely unrelated, unless you add extra syntax or axioms, such as in real-cohesive HoTT.</p>
<p>This can be terribly confusing. For example, the fact that every map in HoTT lifts to a map on the identity types (expressing that if two inputs to a function are equal, then we can prove the outputs are equal) is explained in the HoTT book by saying that this means the function is continuous. So from the HoTT point of view, all functions are &quot;continuous&quot; in that sense. But in the context of constructive analysis <em>inside</em> HoTT, it is not provable that all functions are continuous, and in fact it need not be true, for example if one has the principle of excluded middle.</p>
<p>Even though the link between types and, say, topolgoical spaces (as defined <em>inside</em> HoTT) is broken, the intuition of the internal theory of those spaces is still used to prove the impossibility of type-theoretical proofs. For example, it is not provable that any two points on the higher-inductive circle are equal, which is somewhat odd since in any drawing of a circle there are at least two obvious paths between any two points <span class="math inline"><em>x</em></span> and <span class="math inline"><em>y</em></span>. As a topological counter-argument, it is said that the path from <span class="math inline"><em>x</em></span> to <span class="math inline"><em>y</em></span> cannot be chosen in a &quot;continuous&quot; way, in the sense that if you rotate <span class="math inline"><em>x</em></span> along the circle one full rotation, you'll have to make a &quot;jump&quot; in your choice of path at some point. But this counter-argument is topological in nature, rather than type-theoretic (although there is a way to make it precise type-theoretically).</p>
<p>Indeed, proofs about types such as the higher-inductive circle look nothing like their counterparts in topology. Even still, they satisfy <em>some</em> of the same properties: if we define the &quot;homotopy group&quot; of a pointed type correctly, then there is some evidence that the higher-inductive circles have the same homotopy groups as their topological counterparts in classical mathematics. However, some properties are fundamentally different in a seemingly unfixable way: as a theorem stated inside type theory, there is only one map <span class="math inline"><em>S</em><sup>1</sup>‚ÄÑ‚Üí‚ÄÑ<em>S</em><sup>2</sup></span>, and it is the constant map.</p>
<h2 id="sets">Sets</h2>
<p>There are (at least) three notions of sets:</p>
<ul>
<li>The objects studied by a theory such as ZFC. We can take intersections of any two such sets, even if this does not make sense from an extensional point of view: for example, we can take the intersection of <span class="math inline"><em>œÄ</em></span> with the graph of <span class="math inline"><em>x</em>‚ÄÑ‚Ü¶‚ÄÑ<em>x</em><sup>2</sup></span>, as both objects are sets.</li>
<li>0-types. The behavior of 0-types is very close to ZFC sets. For example, for a map <span class="math inline"><em>f</em></span> between two 0-types (but not between arbitrary types), the following are equivalent:
<ul>
<li><span class="math inline"><em>f</em></span> is an injection (equal outputs implies equal inputs).</li>
<li><span class="math inline"><em>f</em></span> is an embedding (equal inputs is equivalenc to equal outputs).</li>
<li><span class="math inline"><em>f</em></span> is a monomorphism (with respect to all maps on all types).</li>
</ul></li>
<li>A cumulative hierarchy of sets as in e.g. chapter 10.5 of the HoTT book, as an attempt to find a model of an axiomatic set theory like ZFC (although this will likely require choice).</li>
</ul>
<h1 id="type-theoretical-features">Type-theoretical features</h1>
<h2 id="inductionrecursion-inductionrecursion">{induction,recursion}-{induction,recursion}</h2>
<h2 id="initial-algebras">Initial algebras</h2>
<h2 id="coinduction">Coinduction</h2>
<h1 id="category-theory">Category theory</h1>
<h2 id="topos-logic-versus-hott">Topos logic versus HoTT</h2>
<ul>
<li>toposes as models for types of h-level 0</li>
<li>impredicativity: universe of sets as a topos</li>
<li><span class="math inline"><em>Œ£</em></span>, <span class="math inline"><em>Œ†</em></span> and prop trunc already in toposes</li>
</ul>
<h1 id="semantics">Semantics</h1>
<h2 id="categories-with-families">Categories with families</h2>
<ul>
<li>necessary to provide set of types, since necessarily cannot make all maps types: extensionality.</li>
</ul>
<p>So we want to pick out a certain subset of our maps to represent types over contexts. One naive approach is to just take any category and ask for extra data, so that we can tell types apart from arbitrary maps. There are various definitions one can make here, and most of them are unsatisfying since they are <strong>not</strong> invariant under equivalence of the underlying category. For example, there is no contextual category on the 1-object 1-morphism category, but there <em>is</em> a contextual category in which all objects are terminal.</p>
<h2 id="fibrations">Fibrations</h2>
<p>(NB: In category theory, there is the notion of Grothendieck fibration, which is sometimes referred to plainly as a fibration. It is not the same as this concept.)</p>
<p>In categorical semantics of HoTT, we need to distinguish arbitrary maps between the objects (namely <em>context morphisms</em> or <em>substitutions</em>, since the objects represent contexts) from maps that represent types <em>over</em> a context (as types in a context are represented by maps into that context).</p>
<p>Usually, we specify this by saying which maps are <em>fibrations</em>, and more generally we show that the category is a model category. So what it means for a certain semantic object to be a fibration depends on the chosen model category structure. For example, in simplicial sets, a map is defined to be a fibration if it is Kan. Because of the importance of the Kan condition, in semantics of type theory, we sometimes refer to the fibrations as <em>Kan fibrations</em>.</p>
<p>So we say which maps are fibrations, so that we can define a corresponding (say) CwF out of the model category, which has as the types exactly the <em>fibrations</em> into the context.</p>
<h2 id="simplicial-sets">Simplicial sets</h2>
<ul>
<li>presentation in terms of coface and codegeneracy maps is equivalent to saying &quot;take all order-preserving morphisms&quot;</li>
</ul>
<h2 id="cubical-sets">Cubical sets</h2>
<ul>
<li>various iterations</li>
</ul>
      </div>
    </div>

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="js/nav.js"></script>
  </body>
</html>
